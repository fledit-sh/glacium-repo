"""Pointwise engine and helper job classes.

For a walkthrough of how configuration values flow into Pointwise templates,
see :doc:`pointwise_mesh_generation`.
"""

from __future__ import annotations

from pathlib import Path
from typing import Iterable

from glacium.models.job import Job, JobStatus
from glacium.managers.template_manager import TemplateManager
from glacium.utils.logging import log, log_call
from .base_engine import BaseEngine
from .engine_factory import EngineFactory

__all__: Iterable[str] = [
    "PointwiseEngine",
    "PointwiseScriptJob",
]


@EngineFactory.register
class PointwiseEngine(BaseEngine):
    """Execute Pointwise TCL scripts."""

    def run_script(self, exe: str, script: Path, work: Path) -> None:
        """Execute ``exe`` with ``script`` inside ``work`` directory."""

        log.info(f"RUN: {exe} {script.name}")
        self.run([exe, str(script)], cwd=work)


class PointwiseScriptJob(Job):
    """Render a Pointwise .glf script and execute it.

    See also :doc:`pointwise_mesh_generation` for a broader overview of the
    template rendering and mesh-generation pipeline.
    """

    template: Path
    cfg_key_out: str | None = None
    deps: tuple[str, ...] = ()

    # ------------------------------------------------------------------
    def prepare(self):
        """Render the script template into the Pointwise solver directory."""
        work = self.project.paths.solver_dir("pointwise")
        ctx = self._context()
        dest = work / self.template.with_suffix("")
        TemplateManager().render_to_file(self.template, ctx, dest)
        return dest

    def _context(self) -> dict:
        """Return the context dictionary used when rendering templates.

        ``PointwiseScriptJob`` pulls values from the project's global
        configuration and exposes them to Jinja templates.

        ``alias_map`` defines short aliases that keep templates concise while
        documenting where each value originates:

        - ``AIRFOIL`` → ``PWS_AIRFOIL_FILE`` – path to the original airfoil
          coordinates.
        - ``PROFILE1`` → ``PWS_PROFILE1`` – densened profile generated by the
          preprocessing pipeline.
        - ``PROFILE2`` → ``PWS_PROFILE2`` – thickened profile used for XFOIL
          polar generation.
        - ``POLARFILE`` → ``PWS_POLAR_FILE`` – output from the polar analysis.
        - ``SUCTIONFILE`` → ``PWS_SUCTION_FILE`` – suction distribution output.

        ``cfg_key_out`` optionally names a key in the global configuration that
        contains the output filename for this job. Its value is injected as
        ``OUTFILE`` so templates can write results deterministically. After the
        job runs, :meth:`execute` updates that configuration entry to point to
        the produced file on disk.
        """

        cfg = self.project.config
        ctx = cfg.extras.copy()

        # Map Global-Config keys to short aliases exposed in templates. Values
        # like ``PWS_AIRFOIL_FILE`` originate from ``global_config.yaml`` and
        # are mirrored here for readability in Jinja scripts.
        alias_map = {
            "AIRFOIL": "PWS_AIRFOIL_FILE",
            "PROFILE1": "PWS_PROFILE1",
            "PROFILE2": "PWS_PROFILE2",
            "POLARFILE": "PWS_POLAR_FILE",
            "SUCTIONFILE": "PWS_SUCTION_FILE",
        }
        for alias, key in alias_map.items():
            if key in cfg:
                ctx[alias] = cfg[key]

        # If ``cfg_key_out`` is defined, the global configuration supplies the
        # target filename. Inject it as ``OUTFILE`` so the template can place
        # its output accordingly.
        if self.cfg_key_out and self.cfg_key_out in cfg:
            ctx["OUTFILE"] = cfg[self.cfg_key_out]

        return ctx

    @log_call
    def execute(self) -> None:  # noqa: D401
        cfg = self.project.config
        paths = self.project.paths
        work = paths.solver_dir("pointwise")

        dest_script = self.prepare()

        exe = cfg.get("POINTWISE_BIN", "pointwise")
        engine = EngineFactory.create("PointwiseEngine")
        # Run inside the solver directory so relative paths resolve correctly
        engine.run_script(exe, dest_script, work)

        if self.cfg_key_out:
            out_name = cfg.get(self.cfg_key_out)
            if not out_name:
                log.error(f"{self.cfg_key_out} nicht in Global-Config definiert!")
                self.status = JobStatus.FAILED
                return
            produced = work / out_name
            cfg[self.cfg_key_out] = str(produced.relative_to(self.project.root))

