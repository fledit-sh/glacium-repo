"""Create an iced angle-of-attack sweep for the full power study.

The :func:`main` entry point retrieves the latest iced grid generated by
the multishot simulation and runs FENSAP cases over a range of angles of
attack.

Key Functions
-------------
* :func:`get_last_iced_grid` – locate the iced grid with the highest
  numeric suffix.
* :func:`main` – command line interface.

Inputs
------
base_dir : Path | str, optional
    Base directory containing ``05_multishot``.
case_vars : dict[str, Any] | None, optional
    Case variable overrides.

Outputs
-------
Projects created under ``09_iced_sweep``.

Usage
-----
``python scripts/09_iced_sweep_creation.py``

See Also
--------
``docs/full_power_study.rst`` for a complete workflow example.
"""

from __future__ import annotations

from collections.abc import Iterable
from pathlib import Path
from typing import Any
import re

from glacium.api import Project
from glacium.managers.project_manager import ProjectManager
from glacium.utils import reuse_mesh, run_aoa_sweep
from glacium.utils.logging import log

from multishot_loader import load_multishot_project


def _get_expected_shot_index(project: Project) -> str:
    """Return the zero-padded index for the last multishot entry.

    Parameters
    ----------
    project:
        Multishot project providing ``CASE_MULTISHOT``.

    Raises
    ------
    LookupError
        If ``CASE_MULTISHOT`` is not available on ``project``.
    ValueError
        If ``CASE_MULTISHOT`` exists but is empty.
    TypeError
        If the retrieved value is not iterable.
    """

    get = getattr(project, "get", None)
    if get is None:
        raise LookupError("Project does not expose a 'get' method for CASE_MULTISHOT")

    try:
        raw_value = get("CASE_MULTISHOT")
    except KeyError as exc:
        raise LookupError("CASE_MULTISHOT is not defined for the multishot project") from exc

    if raw_value is None:
        raise LookupError("CASE_MULTISHOT is not defined for the multishot project")

    if isinstance(raw_value, (str, bytes)):
        raise TypeError("CASE_MULTISHOT must be an iterable of shots, not a string")

    try:
        items = list(raw_value if isinstance(raw_value, Iterable) else raw_value)
    except TypeError as exc:
        raise TypeError("CASE_MULTISHOT must be iterable to determine the last shot") from exc

    if not items:
        raise ValueError("CASE_MULTISHOT is empty; no iced shots are available")

    return f"{len(items):06d}"


def get_last_iced_grid(project: Project) -> tuple[Path, str]:
    """Return the iced grid path and index for the most recent shot."""

    iced_dir = project.root / "run_MULTISHOT"
    try:
        index = _get_expected_shot_index(project)
    except LookupError:
        pattern = re.compile(r"grid\.ice\.(\d{6})$")
        best: tuple[int, Path] | None = None
        for entry in iced_dir.iterdir():
            match = pattern.fullmatch(entry.name)
            if match:
                idx = int(match.group(1))
                if best is None or idx > best[0]:
                    best = (idx, entry)
        if best is None:
            raise FileNotFoundError(f"No iced grid found in {iced_dir}")
        return best[1], f"{best[0]:06d}"

    grid_path = iced_dir / f"grid.ice.{index}"
    if not grid_path.exists():
        raise FileNotFoundError(
            f"Expected iced grid for shot {index} at {grid_path}, but the file is missing"
        )
    return grid_path, index


def main(
    base_dir: Path | str = Path(""), case_vars: dict[str, Any] | None = None
) -> None:
    """Create AOA sweep using the last iced grid from the multishot project."""

    base_path = Path(base_dir)

    try:
        ms_project = load_multishot_project(base_path / "05_multishot")
    except FileNotFoundError as err:
        log.error(str(err))
        return

    grid_path, shot_index = get_last_iced_grid(ms_project)
    roughness_path = grid_path.with_name(f"roughness.dat.ice.{shot_index}")
    if not roughness_path.exists():
        raise FileNotFoundError(
            f"Missing roughness file for shot {shot_index}: {roughness_path}"
        )

    base = Project(base_path / "10_iced_sweep").name("aoa_sweep")
    base.set("RECIPE", "fensap")

    get = getattr(ms_project, "get", lambda _k: None)
    params = {
        "CASE_CHARACTERISTIC_LENGTH": get("CASE_CHARACTERISTIC_LENGTH"),
        "CASE_VELOCITY": get("CASE_VELOCITY"),
        "CASE_ALTITUDE": get("CASE_ALTITUDE"),
        "CASE_TEMPERATURE": get("CASE_TEMPERATURE"),
        "CASE_YPLUS": get("CASE_YPLUS"),
        "PWS_REFINEMENT": get("PWS_REFINEMENT"),
    }
    if case_vars:
        params.update(case_vars)

    for key, val in params.items():
        base.set(key, val)

    jobs = ["FENSAP_CONVERGENCE_STATS"]
    mesh = lambda proj: reuse_mesh(
        proj, grid_path, "FENSAP_RUN", roughness=roughness_path
    )

    pm = ProjectManager(base_path / "07_iced_aoa0")
    baseline_uid = pm.list_uids()[0]
    baseline_project = Project.load(base_path / "07_iced_aoa0", baseline_uid)
    precomputed = {0.0: baseline_project}
    skip_aoas = {}

    run_aoa_sweep(
        base,
        aoa_start=-4,
        aoa_end=16.0,
        step_sizes=[0.5],
        jobs=jobs,
        postprocess_aoas=set(),
        skip_aoas=skip_aoas,
        precomputed=precomputed,
        mesh_hook=mesh,
    )


if __name__ == "__main__":
    main()
